# WACTF Challenge walkthrough

## Step by Step

### Background
- A service is running somewhere, you are told that this service can be made to print a flag, but you have no idea how.
- You *do* have a copy of the compiled binary though: `jtr`

### Analysis
- First, the old favourite: `strings jtr`
    - No luck :(
    - But we can see "/bin/cat flag.txt" in the output, so we can guess that the flag is on the server.
    - Maybe there's a way to make the program reveal the server's flag.txt to us?
- Get a better idea of what we're looking at: `file jtr`
    - `jtr: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=54ccc37a13f4db7789257fdaba891ebfe8af8eca, not stripped`
    - ELF
    - x86
    - dynamically linked
    - not stripped
- A closer look at the binary's security features: `rabin2 -I jtr`
    ```
    arch     x86
    binsz    6069
    bintype  elf
    bits     32
    canary   false
    class    ELF32
    crypto   false
    endian   little
    havecode true
    intrp    /lib/ld-linux.so.2
    lang     c
    linenum  true
    lsyms    true
    machine  Intel 80386
    maxopsz  16
    minopsz  1
    nx       true
    os       linux
    pcalign  0
    pic      false
    relocs   true
    relro    partial
    rpath    NONE
    static   false
    stripped false
    subsys   linux
    va       true
    ```
    - Of interest are:
        - canary = false
            - No stack canaries means stack smashing is possible
        - nx = true
            - The stack isn't executable. We can't write shellcode to the stack and have it execute. Important!
        - pic = false
            - Not Position-Independent Code (PIC). Locally-defined functions will be found at constant addresses listed in the symbol table, even if ASLR is enabled.
- Run it! `./jtr`
    - Looks like it reads something from stdin and just exits?
    - `python -c 'print("A" * 44)' | ./jtr`
    ```
    Thanks, bye!
    [1]    46025 done                python -c 'print("A" * 44)' |
           46026 segmentation fault  ./jtr
    ```
    - Buffer overflow?
    - At this point we know we're not going to be able to execute shellcode on the stack, but we seem to be able to overwrite some stored return address.
    - ROP? Yes.
- Time to start reversing! `r2 -AA jtr`
- What symbols is it importing? `ii`
    ```
    [Imports]
    001 0x08048340 GLOBAL FUNC fgets
    002 0x08048350 GLOBAL FUNC puts
    003 0x08048360 GLOBAL FUNC system
    004 0x00000000 WEAK NOTYPE __gmon_start__
    005 0x08048370 GLOBAL FUNC __libc_start_main
    006 0x00000000 GLOBAL OBJECT stdin
    ```
    - system() is being imported, this is interesting. Remember we saw "/bin/cat flag.txt" in `strings` output.
- What about local functions? `is~FUNC`
    ```
    028 0x000003d0 0x080483d0  LOCAL   FUNC    0 deregister_tm_clones
    029 0x00000410 0x08048410  LOCAL   FUNC    0 register_tm_clones
    030 0x00000450 0x08048450  LOCAL   FUNC    0 __do_global_dtors_aux
    033 0x00000480 0x08048480  LOCAL   FUNC    0 frame_dummy
    044 0x00000590 0x08048590 GLOBAL   FUNC    2 __libc_csu_fini
    045 0x000003c0 0x080483c0 GLOBAL   FUNC    4 __x86.get_pc_thunk.bx
    049 0x00000594 0x08048594 GLOBAL   FUNC    0 _fini
    057 0x00000530 0x08048530 GLOBAL   FUNC   93 __libc_csu_init
    059 0x00000486 0x08048486 GLOBAL   FUNC   43 win
    061 0x00000390 0x08048390 GLOBAL   FUNC    0 _start
    064 0x000004f9 0x080484f9 GLOBAL   FUNC   47 main
    065 0x00000528 0x08048528 GLOBAL   FUNC    0 __x86.get_pc_thunk.ax
    067 0x000004b1 0x080484b1 GLOBAL   FUNC   72 lolol
    068 0x0000030c 0x0804830c GLOBAL   FUNC    0 _init
    001 0x00000340 0x08048340 GLOBAL   FUNC   16 imp.fgets
    002 0x00000350 0x08048350 GLOBAL   FUNC   16 imp.puts
    003 0x00000360 0x08048360 GLOBAL   FUNC   16 imp.system
    005 0x00000370 0x08048370 GLOBAL   FUNC   16 imp.__libc_start_main
    ```
    - win(), main(), and lolol() are likely to contain user-defined code
- The win() function seems to be of interest. Let's have a look: `pdf@sym.win`
    ```
    / (fcn) sym.win 43
    |   sym.win ();
    |           ; var int local_4h @ ebp-0x4
    |           0x08048486      55             push ebp
    |           0x08048487      89e5           mov ebp, esp
    |           0x08048489      53             push ebx
    |           0x0804848a      83ec04         sub esp, 4
    |           0x0804848d      e896000000     call sym.__x86.get_pc_thunk.ax
    |           0x08048492      056e1b0000     add eax, 0x1b6e
    |           0x08048497      83ec0c         sub esp, 0xc
    |           0x0804849a      8d90b0e5ffff   lea edx, [eax - 0x1a50]
    |           0x080484a0      52             push edx                    ; const char *   string
    |           0x080484a1      89c3           mov ebx, eax
    |           0x080484a3      e8b8feffff     call sym.imp.system         ; int system(const   char *string)
    |           0x080484a8      83c410         add esp, 0x10
    |           0x080484ab      90             nop
    |           0x080484ac      8b5dfc         mov ebx, dword [local_4h]
    |           0x080484af      c9             leave
    \           0x080484b0      c3             ret
    ```
    - win() calls system(). This is a good candidate
## The code
```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

void win(){
    system("/bin/cat flag.txt");
}

int lolol(){
    char input[32];
    fgets(input, 64, stdin);
    printf("Thanks, bye!\n");
    return 1;
}

int main(){
    int yolo = lolol();
    return yolo;
}
```

- Compile with `gcc -m32 -fno-stack-protector -no-pie -o jtr jtr.c`
    - `-m32` - Compile as 32-bit to make analysis easier
    - `-fno-stack-protector` - Disable stack canaries to make overflow easier
    - `-no-pie` - Some gcc's are configured to compile as PIE by default, we don't want this for this challenge
    - Beware of different default compilation options!
        - `gcc -v` to view compiler configuration
- Include a file "flag.txt" containing a win message in the directory you'll be running it in