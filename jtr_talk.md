# Jack the ROPper - An introduction to ROP

## Whoami
- Security consultant, Asterisk
- Previously of ECU, competed in CySCA
- WACTF challenge dev :P

## Why talk?
- I'm not an expert
- Repeating some interesting stuff I've picked up
- If I get something wrong, please shout

## What is ROP
- Return Oriented Programming
- Variation on the classic stack-based buffer overflow that doesn't require the execution of code placed on the stack[[1]](#references)
- Instead, the return address (saved EIP) of a stack frame is overwritten so that when the stack unwinds, execution returns to the address we place on the stack
- Very easy if you have a win() function
- If you want to do more you need to find 'gadgets' of code and chain them together

## How ROP?
- Similar to a standard stack smash, we exploit a buffer overflow condition
- However, instead of writing shellcode to the stack, we simply overflow the return address to point to code we wish to run
```c
void thingy(int a, int b){
    char buf[16];
    int c = 1;
    fgets(buf, 32, stdin);
}
```
```
+----------------+ <- esp points here
|     int c      | 
|----------------|
|   char buf..   | 
|----------------|
|       ..       |
|----------------|
|       ..       |
|----------------|
|       ..       |
|----------------| <- ebp points here
|   saved ebp    |
|----------------|
|  return addr   |
|----------------|
|     int a      |
|----------------|
|     int b      |
+----------------+
         | previous stack frame
         v
```
- After exploit (ret to win)
```
+----------------+ <- esp points here
|     int c      | 
|----------------|
|      AAAA      | 
|----------------|
|      AAAA      |
|----------------|
|      AAAA      |
|----------------|
|      AAAA      |
|----------------| <- ebp points here
|      AAAA      |
|----------------|
|  addr_of_win   |
|----------------|
|     int a      |
|----------------|
|     int b      |
+----------------+
         | previous stack frame
         v
```
- After exploit (stack smash)
```
+----------------+ <- esp points here
|     int c      | 
|----------------|<-+
|   shellcode    |  | 
|----------------|  |
|   shellcode    |  |
|----------------|  |
|   shellcode    |  |
|----------------|  |
|      AAAA      |  |
|----------------|  | <- ebp points here
|      AAAA      |  |
|----------------|  |
| shellcode_addr |--+
|----------------|
|     int a      |
|----------------|
|     int b      |
+----------------+
         | previous stack frame
         v
```

## Why ROP?
- We can still control program flow even if the stack isn't executable
    - Meaning that even if we can't send our own code to exec, we can cause the execution of any code that already exists within the target process

## What can't it do?
- Won't bypass stack canaries
    - `-fno-stack-protector` to disable
    - There are other ways to get around these if the right conditions exist
- Can sometimes be thwarted by ASLR
    - `echo 0 > /proc/sys/kernel/randomize_va_space` to disable
    - If set to the right level
    - And if there's enough entropy >.>
- Position-independent code (`-fPIC`, `-fpic`, `-fpie`, `-shared`) can be a hurdle
    - `-no-pie` and `-fno-PIC` to disable 

## Flavours
- Ret to win
- Ret to libc
- Ret to plt

## References
1. http://phrack.org/issues/49/14.html
2. https://ropemporium.com/