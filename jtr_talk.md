# Jack the ROPper - An introduction to ROP

## Whoami
- Security consultant, Asterisk
- Previously of ECU, competed in CySCA
- WACTF challenge dev :P

## Why talk?
- I'm not an expert
- Repeating some interesting stuff I've picked up

## What is ROP
- Return Oriented Programming
- Variation on the classic stack-based buffer overflow that doesn't require the execution of code placed on the stack[[1]](#references)
- Instead, the return address (saved EIP) of a stack frame is overwritten so that when the stack unwinds, execution returns to the address we place on the stack

## Why ROP?
- We can still control program flow even if the stack isn't executable
    - Meaning that even if we can't send our own code to exec, we can cause the execution of any code in the target process's .text segment

## What can't it do?
- Won't bypass stack canaries
    - `-fno-stack-protector`
- Can be thwarted by ASLR
    - `echo 0 > /proc/sys/kernel/randomize_va_space`
    - If set to the right level
    - And if there's enough entropy >.>

## The challenge
- We have the following code:
```c
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

void win(){
    system("/bin/cat flag.txt");
}

int lolol(){
    char input[32];
    fgets(input, 64, stdin);
    printf("Thanks, bye!\n");
    return 1;
}

int main(){
    int yolo = lolol();
    return yolo;
}
```
- Compiled with `gcc -m32 -fno-stack-protector -o jtr jtr.c`
    - `-m32` - Compile as 32-bit to make analysis easier
    - `-fno-stack-protector` - Disable stack canaries to make overflow easier

## Doing more
- Popping shell
    - Roll your own stack frame
    - May require disabling ASLR?
- ROP chains / gadgets

## References
1. http://phrack.org/issues/49/14.html
2. https://ropemporium.com/